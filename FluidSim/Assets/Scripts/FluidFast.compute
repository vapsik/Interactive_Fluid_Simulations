
#pragma kernel VelocityBrush
#pragma kernel DyeBrush
#pragma kernel AdvectVelocities
#pragma kernel AdvectDye
#pragma kernel ComputeDivergence
#pragma kernel SolvePressure
#pragma kernel SubtractGradient

Texture2D<float> _ReadVelocityX;
Texture2D<float> _ReadVelocityY;
RWTexture2D<float> _WriteVelocityX;
RWTexture2D<float> _WriteVelocityY;

Texture2D<float> _SolidCellMap;
Texture2D<float4> _ReadDye;
RWTexture2D<float4> _WriteDye;

Texture2D<float> _ReadPressure;
RWTexture2D<float> _WritePressure;

Texture2D<float> _ReadDivergence;
RWTexture2D<float> _WriteDivergence;




//general float values
float _CellSize;
float _TimeStep;
float _CountX;
float _CountY;
float _Decay;

//for velocity brush and dye brush 
int2 _CentreCoord;
int _NumCellsHalf;
float2 _MouseDelta;
float _Strength;

float4 _AppliedDyeColor;


SamplerState _LinearClamp;

[numthreads(8,8,1)]
void AdvectDye (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _CountX || id.y >= _CountY){
        return;
    }
    if (_SolidCellMap[id.xy]>0.5){
        return;
    }

    float2 uv = (id.xy + 0.5) / float2(_CountX, _CountY);

    //for solid edges:
    float vL = (id.x == 0) ? 0.0 : _ReadVelocityX[id.xy];
    float vR = (id.x == _CountX-1) ? 0.0 : _ReadVelocityX[id.xy + int2(1, 0)];
    float vB = (id.y == 0) ? 0.0 : _ReadVelocityY[id.xy];
    float vT = (id.y == _CountY-1) ? 0.0 : _ReadVelocityY[id.xy + int2(0, 1)];

    float2 velocity = 0.5*float2(vL + vR, vB + vT);

    float2 prevPos = uv - velocity * _TimeStep / _CellSize / float2(_CountX, _CountY);
    float4 newValue = _ReadDye.SampleLevel(_LinearClamp, prevPos, 0);  // Fixed: Explicitly float4 for clarity

    _WriteDye[id.xy] = newValue * (1.0 - _Decay);
}

[numthreads(8,8,1)]
void DyeBrush(uint3 id : SV_DispatchThreadID){
    
    
    int x = _CentreCoord.x + id.x -_NumCellsHalf;
    int y = _CentreCoord.y + id.y -_NumCellsHalf;
    
    if (x < 0 || x >= _CountX || y < 0 || y >= _CountY){
        return;
    }

    if((id.x-_NumCellsHalf)*(id.x-_NumCellsHalf)+(id.y-_NumCellsHalf)*(id.y-_NumCellsHalf) > _NumCellsHalf*_NumCellsHalf){
        return;
    }

    if (_SolidCellMap[int2(x,y)].r > 0.5){
        return;
    }

    _WriteDye[int2(x,y)] = _AppliedDyeColor;
}

[numthreads(8,8,1)]
void VelocityBrush(uint3 id : SV_DispatchThreadID){


    int x = _CentreCoord.x + id.x -_NumCellsHalf;
    int y = _CentreCoord.y + id.y -_NumCellsHalf;
    
    if (x < 0 || x >= _CountX || y < 0 || y >= _CountY){
        return;
    }

    
    if(_SolidCellMap[int2(x,y)].x > 0.5){
        return;
    }

    float distSqr = (x-_CentreCoord.x)*(x-_CentreCoord.x) + (y-_CentreCoord.y)*(y-_CentreCoord.y);
    
    if(distSqr > _NumCellsHalf*_NumCellsHalf){
        return;
    }

    
    float weight = 1.0 - clamp(distSqr / (_NumCellsHalf*_NumCellsHalf), 0.0, 0.8);

    _WriteVelocityX[int2(x,y)] = _ReadVelocityX[int2(x,y)] + _MouseDelta.x * weight * _Strength;
    _WriteVelocityY[int2(x,y)] = _ReadVelocityY[int2(x,y)] + _MouseDelta.y * weight * _Strength;
}



float BilinearScalar(Texture2D<float> scalarField, float2 pos){

    int2 pivot = floor(pos);
    float2 weights = pos-pivot;
    int2 horizontal = int2(1, 0);
    int2 vertical = int2(0, 1);
    int2 diagonal = horizontal + vertical;

    return scalarField[pivot.xy]*(1-weights.x)*(1-weights.y) 
        + scalarField[pivot.xy+horizontal]*(weights.x)*(1-weights.y) + scalarField[pivot.xy+vertical]*(1-weights.x)*(weights.y)
        + scalarField[pivot.xy+diagonal]*(weights.x)*(weights.y);
}

//Advection for Staggered Grid
[numthreads(8,8,1)]  
void AdvectVelocities (uint3 id : SV_DispatchThreadID)
{   if(id.x >= _CountX + 1 || id.y >= _CountY + 1){
        return;
    }
    if(_SolidCellMap[id.xy].x > 0.5){
        return;
    }

    float2 sampledVelocityComponents = float2(0.0, 0.0);
    float2 spaceVelX = float2(_CountX + 1, _CountY); 
    float2 spaceVelY = float2(_CountX, _CountY + 1);

    // X velocity advection
    if(id.x < _CountX + 1 && id.y < _CountY){

        float2 currentPos = id.xy + int2(-0.5,+0.5);
        currentPos = float2(clamp(currentPos.x, 0, _CountX), clamp(currentPos.y, 0, _CountY+1));
        float backtrackVel = float2(_ReadVelocityX[id.xy], BilinearScalar(_ReadVelocityY, currentPos));
        float2 deltaIndex = backtrackVel * _TimeStep / _CellSize;
        float2 samplePos = currentPos - deltaIndex;
        samplePos = float2(clamp(samplePos.x, 0, _CountX+1), clamp(samplePos.y, 0, _CountY));
        sampledVelocityComponents.x = BilinearScalar(_ReadVelocityX, samplePos);
    }
    
    // Y velocity advection
    if(id.x < _CountX && id.y < _CountY + 1){
        float2 currentPos = id.xy + int2(+0.5,-0.5);
        currentPos = float2(clamp(currentPos.x, 0, _CountX+1), clamp(currentPos.y, 0, _CountY));
        float backtrackVel = float2(BilinearScalar(_ReadVelocityX, currentPos), _ReadVelocityY[id.xy]);
        float2 deltaIndex = backtrackVel * _TimeStep / _CellSize;
        float2 samplePos = currentPos - deltaIndex;
        samplePos = float2(clamp(samplePos.x, 0, _CountX), clamp(samplePos.y, 0, _CountY+1));
        sampledVelocityComponents.y = BilinearScalar(_ReadVelocityY, samplePos);
    }

    _WriteVelocityX[id.xy] = sampledVelocityComponents.x;
    _WriteVelocityY[id.xy] = sampledVelocityComponents.y;
}



[numthreads(8,8,1)]
void ComputeDivergence(uint3 id : SV_DispatchThreadID)
{
    // For open boundaries, extrapolate velocities at edges
    //float vL = (id.x == 0) ? _Velocity[id.xy + int2(1, 0)].x : _Velocity[id.xy + int2(-1, 0)].x;
    //float vR = (id.x >= _CountX-1) ? _Velocity[id.xy + int2(-1, 0)].x : _Velocity[id.xy + int2(1, 0)].x;
    //float vB = (id.y == 0) ? _Velocity[id.xy + int2(0, 1)].y : _Velocity[id.xy + int2(0, -1)].y;
    //float vT = (id.y >= _CountY-1) ? _Velocity[id.xy + int2(0, -1)].y : _Velocity[id.xy + int2(0, 1)].y;    

    if (_SolidCellMap[id.xy].x > 0.5)
    {
        _WriteDivergence[id.xy] = 0;
        return;
    }

    //implicitly applies edge boundaries
    float vL = _ReadVelocityX[id.xy];
    float vR = _ReadVelocityX[id.xy + int2(1, 0)];
    float vB = _ReadVelocityY[id.xy];
    float vT = _ReadVelocityY[id.xy + int2(0, 1)];

    float div = 0.5 * (vR - vL + vT - vB);
    _WriteDivergence[id.xy] = div;
}

[numthreads(8,8,1)]
void SolvePressure(uint3 id : SV_DispatchThreadID){

    uint w, h;
    _WritePressure.GetDimensions(w, h);
    if (id.x == 0 || id.x >= w-1 || id.y == 0 || id.y >= h-1)
    {
        //_WritePressure[id.xy] = 0;        

        if(_SolidCellMap[id.xy].r > 0.5){
            _WritePressure[id.xy] = 0;
        }
        else if (id.x == 0){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(1,  0)];
        }
        else if (id.x >= w-1){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(-1,  0)];
        }
        else if (id.y == 0){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(0,  1)];
        }
        else if (id.y >= h-1){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(0,  -1)];
        }

        return;
    }

    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WritePressure[id.xy] = 0;
        return;
    }

    //center pressure
    float pC = _ReadPressure[id.xy];

    float pL = (_SolidCellMap[id.xy + int2(-1,  0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(-1,  0)];
    float pR = (_SolidCellMap[id.xy + int2( 1,  0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2( 1,  0)];
    float pB = (_SolidCellMap[id.xy + int2( 0, -1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2( 0, -1)];
    float pT = (_SolidCellMap[id.xy + int2(0,  1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(0,  1)];
    
    float divergence = _ReadDivergence[id.xy];
    
    float newPressure = (pL + pR + pB + pT - divergence) * 0.25;
    _WritePressure[id.xy] = newPressure;
}

[numthreads(8,8,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _CountX + 1 || id.y >= _CountY + 1){
        return;
    }
    if(_SolidCellMap[id.xy].x > 0.5){
        return;
    }

    // Subtract gradient for X velocity
    if(id.x < _CountX + 1 && id.y < _CountY){
        float pLeft = (id.x == 0) ? _ReadPressure[int2(0, id.y)] : _ReadPressure[int2(id.x - 1, id.y)];
        float pRight = (id.x == _CountX) ? _ReadPressure[int2(_CountX - 1, id.y)] : _ReadPressure[int2(id.x, id.y)];
        float gradX = (pRight - pLeft) / _CellSize;
        _WriteVelocityX[id.xy] = _ReadVelocityX[id.xy] - gradX;
    }
    
    // Subtract gradient for Y velocity
    if(id.x < _CountX && id.y < _CountY + 1){
        float pBottom = (id.y == 0) ? _ReadPressure[int2(id.x, 0)] : _ReadPressure[int2(id.x, id.y - 1)];
        float pTop = (id.y == _CountY) ? _ReadPressure[int2(id.x, _CountY - 1)] : _ReadPressure[int2(id.x, id.y)];
        float gradY = (pTop - pBottom) / _CellSize;
        _WriteVelocityY[id.xy] = _ReadVelocityY[id.xy] - gradY;
    }
}