#pragma kernel Advect

RWTexture2D<float4> _Write;
Texture2D<float4> _Read;
Texture2D<float4> _Velocity;
RWTexture2D<float4> _WriteVelocity;
RWTexture2D<float4> _ReadVelocity;

#pragma kernel ComputeDivergence
#pragma kernel SolvePressure
#pragma kernel SubtractGradient

RWTexture2D<float> _WritePressure;
Texture2D<float> _ReadPressure;
RWTexture2D<float> _WriteDivergence;
Texture2D<float> _ReadDivergence;

//for compatibility with float-based textures
Texture2D<float4> _SolidCellMap;

SamplerState _LinearClamp;

float _TimeStep;
float _Decay;
float2 _TextureSize;

[numthreads(8,8,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
    float2 uv = (id.xy + 0.5) / _TextureSize;
    float2 velocity = _Velocity.SampleLevel(_LinearClamp, uv, 0).xy;
    float2 prevPos = uv - (velocity * _TimeStep);
    float4 newValue = _Read.SampleLevel(_LinearClamp, prevPos, 0);
    
    _Write[id.xy] = newValue * (1.0 - _Decay);
}

[numthreads(8,8,1)]
void ComputeDivergence (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WriteDivergence.GetDimensions(w, h);
    
    // For open boundaries, extrapolate velocities at edges
    float vLx = (id.x == 0) ? _Velocity[id.xy + int2(1, 0)].x : _Velocity[id.xy + int2(-1, 0)].x;
    float vRx = (id.x >= w-1) ? _Velocity[id.xy + int2(-1, 0)].x : _Velocity[id.xy + int2(1, 0)].x;
    float vBy = (id.y == 0) ? _Velocity[id.xy + int2(0, 1)].y : _Velocity[id.xy + int2(0, -1)].y;
    float vTy = (id.y >= h-1) ? _Velocity[id.xy + int2(0, -1)].y : _Velocity[id.xy + int2(0, 1)].y;
    
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WriteDivergence[id.xy] = 0;
        return;
    }
    
    float div = 0.5 * (vRx - vLx + vTy - vBy);
    _WriteDivergence[id.xy] = div;
}

[numthreads(8,8,1)]
void SolvePressure (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WritePressure.GetDimensions(w, h);
    if (id.x == 0 || id.x >= w-1 || id.y == 0 || id.y >= h-1)
    {
        //_WritePressure[id.xy] = 0;        

        if(_SolidCellMap[id.xy].r > 0.5){
            _WritePressure[id.xy] = 0;
        }
        else if (id.x == 0){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(1,  0)];
        }
        else if (id.x >= w-1){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(-1,  0)];
        }
        else if (id.y == 0){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(0,  1)];
        }
        else if (id.y >= h-1){
            _WritePressure[id.xy] = _ReadPressure[id.xy + int2(0,  -1)];
        }

        return;
    }

    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WritePressure[id.xy] = 0;
        return;
    }

    //center pressure
    float pC = _ReadPressure[id.xy];

    float pL = (_SolidCellMap[id.xy + int2(-1,  0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(-1,  0)];
    float pR = (_SolidCellMap[id.xy + int2( 1,  0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2( 1,  0)];
    float pB = (_SolidCellMap[id.xy + int2( 0, -1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2( 0, -1)];
    float pT = (_SolidCellMap[id.xy + int2(0,  1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(0,  1)];
    
    float divergence = _ReadDivergence[id.xy];
    
    float newPressure = (pL + pR + pB + pT - divergence) * 0.25;
    _WritePressure[id.xy] = newPressure;
}

[numthreads(8,8,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WriteVelocity.GetDimensions(w, h);
    
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WriteVelocity[id.xy] = float4(0,0,0,0);
        return;
    }
    
    // Extrapolate pressures at boundaries for open boundaries
    float pL = (id.x == 0) ? _ReadPressure[id.xy + int2(1, 0)] : _ReadPressure[id.xy + int2(-1, 0)];
    float pR = (id.x >= w-1) ? _ReadPressure[id.xy + int2(-1, 0)] : _ReadPressure[id.xy + int2(1, 0)];
    float pB = (id.y == 0) ? _ReadPressure[id.xy + int2(0, 1)] : _ReadPressure[id.xy + int2(0, -1)];
    float pT = (id.y >= h-1) ? _ReadPressure[id.xy + int2(0, -1)] : _ReadPressure[id.xy + int2(0, 1)];
    
    float2 velocity = _WriteVelocity[id.xy].xy;
    
    velocity.x -= 0.5 * (pR - pL);
    velocity.y -= 0.5 * (pT - pB);

    _WriteVelocity[id.xy] = float4(velocity, 0, 0);
}