#pragma kernel Advect
RWTexture2D<float4> _Write;
Texture2D<float4> _Read;
Texture2D<float4> _Velocity;
RWTexture2D<float4> _WriteVelocity;
Texture2D<float4> _ReadVelocity;

#pragma kernel ComputeDivergence
#pragma kernel SolvePressure
#pragma kernel SubtractGradient
RWTexture2D<float> _WritePressure;
Texture2D<float> _ReadPressure;
RWTexture2D<float> _WriteDivergence;
Texture2D<float> _ReadDivergence;

//for compatibility with float-based textures
Texture2D<float4> _SolidCellMap;

SamplerState _LinearClamp;

float _TimeStep;
float _Decay;
float2 _TextureSize;

[numthreads(8,8,1)]
void ComputeDivergence (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WriteDivergence.GetDimensions(w, h);
    
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WriteDivergence[id.xy] = 0;
        return;
    }
    
    // For open boundaries: use one-sided differences at edges, zero gradient assumption
    float vLx, vRx, vBy, vTy;
    
    // Left boundary (x = 0): use forward difference
    if (id.x == 0)
    {
        vLx = _Velocity[id.xy].x;
        vRx = _Velocity[id.xy + int2(1, 0)].x;
    }
    // Right boundary (x = w-1): use backward difference
    else if (id.x >= w-1)
    {
        vLx = _Velocity[id.xy + int2(-1, 0)].x;
        vRx = _Velocity[id.xy].x;
    }
    // Interior: centered difference
    else
    {
        vLx = _Velocity[id.xy + int2(-1, 0)].x;
        vRx = _Velocity[id.xy + int2(1, 0)].x;
    }
    
    // Bottom boundary (y = 0): use forward difference
    if (id.y == 0)
    {
        vBy = _Velocity[id.xy].y;
        vTy = _Velocity[id.xy + int2(0, 1)].y;
    }
    // Top boundary (y = h-1): use backward difference
    else if (id.y >= h-1)
    {
        vBy = _Velocity[id.xy + int2(0, -1)].y;
        vTy = _Velocity[id.xy].y;
    }
    // Interior: centered difference
    else
    {
        vBy = _Velocity[id.xy + int2(0, -1)].y;
        vTy = _Velocity[id.xy + int2(0, 1)].y;
    }
    
    float div = 0.5 * (vRx - vLx + vTy - vBy);
    _WriteDivergence[id.xy] = div;
}

[numthreads(8,8,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _Write.GetDimensions(w, h);
    
    // Handle solid cells
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _Write[id.xy] = float4(0, 0, 0, 0);
        return;
    }
    
    float2 uv = (id.xy + 0.5) / _TextureSize;
    float2 velocity = _Velocity.SampleLevel(_LinearClamp, uv, 0).xy;
    float2 prevPos = uv - (velocity * _TimeStep);
    
    // Clamp to domain bounds for open boundaries
    prevPos = clamp(prevPos, float2(0.0, 0.0), float2(1.0, 1.0));
    
    float4 newValue = _Read.SampleLevel(_LinearClamp, prevPos, 0);
    _Write[id.xy] = newValue * (1.0 - _Decay);
}

[numthreads(8,8,1)]
void SolvePressure (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WritePressure.GetDimensions(w, h);
    
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WritePressure[id.xy] = 0;
        return;
    }
    
    // Open boundary conditions: Zero pressure (Dirichlet)
    // This allows flow to exit/enter the domain freely
    if (id.x == 0 || id.x >= w-1 || id.y == 0 || id.y >= h-1)
    {
        _WritePressure[id.xy] = 0;
        return;
    }

    // Interior Jacobi iteration
    float pC = _ReadPressure[id.xy];

    float pL = (_SolidCellMap[id.xy + int2(-1, 0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(-1, 0)];
    float pR = (_SolidCellMap[id.xy + int2(1, 0)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(1, 0)];
    float pB = (_SolidCellMap[id.xy + int2(0, -1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(0, -1)];
    float pT = (_SolidCellMap[id.xy + int2(0, 1)].r > 0.5) ? pC : _ReadPressure[id.xy + int2(0, 1)];
    
    float divergence = _ReadDivergence[id.xy];
    
    float newPressure = (pL + pR + pB + pT - divergence) * 0.25;
    _WritePressure[id.xy] = newPressure;
}


[numthreads(8,8,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    _WriteVelocity.GetDimensions(w, h);
    
    if (_SolidCellMap[id.xy].r > 0.5)
    {
        _WriteVelocity[id.xy] = float4(0,0,0,0);
        return;
    }
    
    float2 velocity = _WriteVelocity[id.xy].xy;
    
    // For open boundaries with zero pressure, use one-sided differences
    float pL = (id.x == 0) ? 0.0 : _ReadPressure[id.xy + int2(-1, 0)];
    float pR = (id.x >= w-1) ? 0.0 : _ReadPressure[id.xy + int2(1, 0)];
    float pB = (id.y == 0) ? 0.0 : _ReadPressure[id.xy + int2(0, -1)];
    float pT = (id.y >= h-1) ? 0.0 : _ReadPressure[id.xy + int2(0, 1)];
    
    velocity.x -= 0.5 * (pR - pL);
    velocity.y -= 0.5 * (pT - pB);


    /*if(id.x == 0 || id.x == w-1){
        velocity.x = 0.0;
    }

    if(id.y == 0 || id.y == h-1){
        velocity.y = 0.0;
    }*/

    /*if (_SolidCellMap[id.xy+int2(1,0)].r > 0.5 || _SolidCellMap[id.xy+int2(-1,0)].r > 0.5)
    {
        velocity.x = 0.0;
    }

    if (_SolidCellMap[id.xy+int2(0,1)].r > 0.5 || _SolidCellMap[id.xy+int2(0,-1)].r > 0.5)
    {
        velocity.y = 0.0;
    }*/

    _WriteVelocity[id.xy] = float4(velocity, 0, 0);
}